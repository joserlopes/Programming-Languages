let mod = fn x: int, p: int => {
    x - (p * (x / p))
};

let filter: int->list<int>->list<int> = fn p: int, l: list<int> => {
  match l {
    | nil -> nil
    | v :: tail -> 
      if (mod(v)(p) == 0) {
        filter(p)(tail)
      } else {
        lcons(v, filter(p)(tail))
      }
  }
};

let from: int->list<int> = fn n: int => {
  lcons(n, from(n + 1))
};

let sieve: list<int>->list<int> = fn l: list<int> => {
  match l {
    | nil -> nil
    | v :: tail -> lcons(v, sieve(filter(v)(tail)))
  }
};

let primes = box(sieve(from(2)));
let count = box(10);
while (*count != 0) {
  match *primes {
    | nil -> println("never happens"); nil
    | v :: tail -> println(v); primes := tail
  };
  count := *count - 1
};;
