let mod = fn x, p => {
    x - (p * (x / p))
};
let filter = fn p, list => {
  match list {
    | nil -> nil
    | v :: tail -> 
      if (mod(v)(p) == 0) {
        filter(p)(tail)
      } else {
        lcons(v, filter(p)(tail))
      }
  }
};
let from = fn n => {
  lcons(n, from(n + 1))
};
let sieve = fn list => {
  match list {
    | nil -> nil
    | v :: tail -> lcons(v, sieve(filter(v)(tail)))
  }
};
let primes = box(sieve(from(2)));
let count = box(10);
while (*count ~= 0) {
  match *primes {
    | nil -> println("never happens")
    | v :: tail -> println(v); primes := tail
  };
  count := *count - 1
};;
