let mod = fn x: int, p: int => {
    x - (p * (x / p))
};
let filter = fn p: int, l: int => list<int> {
  match l {
    | nil -> nil
    | v :: tail -> 
      if (mod(v)(p) == 0) {
        filter(p)(tail)
      } else {
        lcons(v, filter(p)(tail))
      }
  }
};
let from = fn n: int => list<int> {
  lcons(n, from(n + 1))
};

let sieve = fn l: int => list<int> {
  match l {
    | nil -> nil
    | v :: tail -> lcons(v, sieve(filter(v)(tail)))
  }
};
let primes = box(sieve(from(2)));
let count = box(10);
while (*count ~= 0) {
  match *primes {
    | nil -> println("never happens")
    | v :: tail -> println(v); primes := tail
  };
  count := *count - 1
};;
